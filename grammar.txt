### Meta
List[item] -> {}
            | item ("\n" item)* "\n"?
            | item ("," item)* ","?
Delimited[item]
           -> "(" List[item] ")" | item
Left[op, operand]
           -> (Left[op, operand] op)? operand
Right[op, operand]
           -> operand (op Right[op, operand])?

### Main
program    -> List[expression] EOF
expression -> assignment
            | declaration
            | keyword
            | lambda
            | boolor
assignment -> declaration OP_ASSIGN expression
declaration-> ("let" | "const") Delimited[target]
target     -> typehint? NAME
typehint   -> "<" type ">"
type       -> identifier ("[" List[type] "]")?
keyword    -> if | case | try | for | while
            | iter | do | object | enum | module | exception | mutable
            | throw | raises | yield | yieldfrom
if         -> "if" expression "then" expression ("else" expression)?
case       -> "case" primary "in" mapping ("else" expression)?
try        -> "try" expression ("catch" identifier ("as" NAME)? expression)+
for        -> "for" Delimited[NAME] "in" expression block
while      -> "while" expression block
iter       -> "iter" (list | for | while)
do         -> "do" block
object     -> "object" block
enum       -> "enum" "flags"? "{" List[enumitem] "}"
enumitem   -> NAME ("=" NUMBER)?
module     -> "module" block
exception  -> "exception" block
mutable    -> "mutable" (object | iter | mapping | list | tuple | STRING)
throw      -> "throw" expression
raises     -> "raises" "(" expression "," identifier ")"
lambda     -> Delimited[param] "->" expression
param      -> typehint NAME (":" expression)?
            | ("*" | "**") typehint NAME
boolor     -> Right["or", boolxor]      # any() - returns the first truthy argument, else the last
boolxor    -> Right["xor", booland]     # parity()
booland    -> Right["and", inclusion]   # all() - return the first falsey argument, else the last
inclusion  -> Right[("in" | "not" "in"), identity]
identity   -> Right[("is" | "is" "not"), comparison]
comparison -> Right[OP_COMP, bitor]     # comp()
bitor      -> Left["|", bitxor]         # bitor()
bitxor     -> Left["^", bitand]         # bitxor()
bitand     -> Left["&", shift]          # bitand()
shift      -> Left[("<<" | ">>"), add]  # shift()
addition   -> Left[("+" | "-"), mult]   # sum()
product    -> Left[("*" | "/"), modulus]# product()
modulus    -> Left["%", exponent]       # mod()
exponent   -> Right["**", unary]        # power()
unary      -> ("not" | "!" | "-") unary # inv(), bitinv(), neg()
            | primary
primary    -> atom ("." NAME | "(" List[arg] ")" | list)*
arg        -> ("*" | "**")? expression | NAME ":" expression
atom       -> mapping | block | list | grouping | tuple | identifier | literal
mapping    -> "{" List[pair] "}"
pair       -> expression ":" expression
block      -> "{" List[expression] "}"
list       -> "[" (range | List[expression]) "]"
range      -> expression ".." ("="? expression)? ("," unary)?
grouping   -> "(" expression ")"
tuple      -> "(" List[expression] ")"
identifier -> NAME
literal    -> STRING | NUMBER | "true" | "false" | "none" | "break" | "continue" | "pass"
