List[item] -> "\n"? item (("\n" item)+ | ("," "\n"? item)* ","?) "\n"?
Left[op, operand]
           -> operand (op operand)*
Right[op, operand]
           -> operand (op Right[op, operand])?

program    -> List[assignment] "EOF"
assignment -> ("(" List[target] ")" | target) "=" assignment
            | target AUG_ASSIGN assignment
            | declaration
target     -> ("nonlocal" | "const")? typehint? IDENTIFIER
declaration-> typehint IDENTIFIER
            | keyword
typehint   -> "<" type ">"
type       -> IDENTIFIER ("[" List[type] "]")?
keyword    -> if | case | for | while
            | iter | object | exception | mutable
            | return | yield | yieldfrom
            | break | continue
            | lambda | boolor
if         -> "if" assignment "then" keyword ("else" keyword)
case       -> "case" assignment "in" map ("else" keyword)
for        -> "for" vars "in" keyword block
vars       -> "(" List[IDENTIFIERS] ")" | IDENTIFIER
while      -> "while" assignment block
iter       -> "iter" keyword
object     -> "object" block
exception  -> "exception" block
mutable    -> "mutable" keyword
return     -> "return" keyword
yieldfrom  -> "yield" "from" assignment
yield      -> "yield" assignment
break      -> "break"
continue   -> "continue"
lambda     -> "(" List[param] ")" "->" keyword
param      -> vparam | kwparam
kwparam    -> typehint (IDENTIFIER "=" keyword | "**" IDENTIFIER)
vparam     -> typehint "*"? IDENTIFIER
boolor     -> Right["or", boolxor]      # any() - returns the first truthy argument, else the last
boolxor    -> Right["xor", booland]     # parity()
booland    -> Right["and", comparison]  # all() - return the first falsey argument, else the last
comparison -> Right[comp, bitor]        # comp()
bitor      -> Left["|", bitxor]         # bitor()
bitxor     -> Left["^", bitand]         # bitxor()
bitand     -> Left["&", shift]          # bitand()
shift      -> Left[("<<" | ">>"), add]  # shift(); a >> b -> a << -b; a << b << ... -> shift(a, sum(b, ...))
addition   -> Left[("+" | "-"), mult]   # sum(); sum(sum(*addends), neg(sum(*subtrahends)))
product    -> Left[("*" | "/"), mod]    # product(); product(product(*multipicands), reciprocal(product(*divisors)))
modulus    -> Left["%", exp]            # mod()
exponent   -> Right["**", unary]        # power()
unary      -> ("not" | "!" | "-") unary # inv(), bitinv(), neg()
            | primary
primary    -> atom ("." IDENTIFIER | "(" List[arg] ")" | list)*
arg        -> varg | kwarg
kwarg      -> "**" keyword | IDENTIFIER "=" keyword
varg       -> "*"? keyword
atom       -> mapping | block | list | group | tuple | literal
mapping    -> "{" List[pair] "}"
pair       -> assignment ":" assignment
block      -> "{" List[declaration] "}"
list       -> "[" (assignment ".." keyword? ("," keyword)? | List[assignment]) "]"
group      -> "(" keyword ")"
tuple      -> "(" List[assignment] ")"
literal    -> IDENTIFIER | STRING | NUMBER | "true" | "false" | "none"
